<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emil Blaignan">
<meta name="dcterms.date" content="2025-02-24">

<title>JAX-Driven Heat Diffusion: Sparse and Vectorized PDE Simulation – Emil Blaignan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-e36ce5c26c48eccda62d8cde5e438854.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Emil Blaignan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../personal.html"> 
<span class="menu-text">Personal</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/emilblaignan"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/emil-blaignan/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">JAX-Driven Heat Diffusion: Sparse and Vectorized PDE Simulation</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">JAX</div>
                <div class="quarto-category">Scipy</div>
                <div class="quarto-category">NumPy</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Emil Blaignan </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 24, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#the-math-of-heat-diffusion-simulations" id="toc-the-math-of-heat-diffusion-simulations" class="nav-link" data-scroll-target="#the-math-of-heat-diffusion-simulations">The Math of Heat Diffusion Simulations</a>
  <ul class="collapse">
  <li><a href="#the-continuous-2d-heat-equation" id="toc-the-continuous-2d-heat-equation" class="nav-link" data-scroll-target="#the-continuous-2d-heat-equation">The Continuous 2D Heat Equation</a></li>
  <li><a href="#discretization-using-finite-differences" id="toc-discretization-using-finite-differences" class="nav-link" data-scroll-target="#discretization-using-finite-differences">Discretization Using Finite Differences</a></li>
  <li><a href="#matrix-representation-of-the-finite-difference-method" id="toc-matrix-representation-of-the-finite-difference-method" class="nav-link" data-scroll-target="#matrix-representation-of-the-finite-difference-method">Matrix Representation of the Finite Difference Method</a></li>
  </ul></li>
  <li><a href="#initializing-our-heat-diffusion-simulation" id="toc-initializing-our-heat-diffusion-simulation" class="nav-link" data-scroll-target="#initializing-our-heat-diffusion-simulation">Initializing Our Heat Diffusion Simulation</a></li>
  <li><a href="#heat-diffusion-with-matrix-vector-multiplication" id="toc-heat-diffusion-with-matrix-vector-multiplication" class="nav-link" data-scroll-target="#heat-diffusion-with-matrix-vector-multiplication">Heat Diffusion With Matrix-Vector Multiplication</a></li>
  <li><a href="#optimizing-computation-with-sparse-matrices" id="toc-optimizing-computation-with-sparse-matrices" class="nav-link" data-scroll-target="#optimizing-computation-with-sparse-matrices">Optimizing Computation With Sparse Matrices</a></li>
  <li><a href="#direct-numpy-vectorization" id="toc-direct-numpy-vectorization" class="nav-link" data-scroll-target="#direct-numpy-vectorization">Direct NumPy Vectorization</a></li>
  <li><a href="#jax-jit-compilation-for-maximum-speed" id="toc-jax-jit-compilation-for-maximum-speed" class="nav-link" data-scroll-target="#jax-jit-compilation-for-maximum-speed">JAX JIT Compilation for Maximum Speed</a></li>
  <li><a href="#conclusion-applications-to-deep-learning" id="toc-conclusion-applications-to-deep-learning" class="nav-link" data-scroll-target="#conclusion-applications-to-deep-learning">Conclusion: Applications to Deep Learning</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="2D_heat_diff.png" class="img-fluid"></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Heat diffusion is a fundamental process in physics and engineering, described by the heat equation, a partial differential equation (PDE) modeling thermal energy transfer. In this project, we simulate 2D heat diffusion using multiple computational approaches:</p>
<ul>
<li>Matrix-vector multiplication (explicit finite difference method).</li>
<li>Sparse matrix representation in JAX (efficient storage and computation).</li>
<li>NumPy vectorized operations (direct array manipulation with <code>np.roll</code>).</li>
<li>JAX-optimized just-in-time (JIT) compilation (high-speed execution).</li>
</ul>
<p>The objective is to compare performance and efficiency across these methods while maintaining correct boundary conditions (to simulate heat diffusion properly) and stable numerical updates. Sparse representations and JIT-optimized computations significantly reduce runtime complexity compared to basic implementations. The results will be visualized using heatmaps at regular intervals to analyze diffusion patterns. Additionally, results will be accompanied by runtimes to compare code efficiency.</p>
</section>
<section id="the-math-of-heat-diffusion-simulations" class="level2">
<h2 class="anchored" data-anchor-id="the-math-of-heat-diffusion-simulations">The Math of Heat Diffusion Simulations</h2>
<p>Before we dive into the code that simulates heat diffusion, we must understand the math behind it.</p>
<section id="the-continuous-2d-heat-equation" class="level3">
<h3 class="anchored" data-anchor-id="the-continuous-2d-heat-equation">The Continuous 2D Heat Equation</h3>
<p>The heat diffusion equation describes how heat spreads over time in a two-dimensional space. The general form is:</p>
<p><span class="math display">\[\frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(u(x, y, t)\)</span> represents the temperature at position <span class="math inline">\((x, y)\)</span> at time <span class="math inline">\(t\)</span>.</li>
<li>The right-hand side represents the Laplacian operator, which models how heat spreads from a point to its neighbors.</li>
</ul>
</section>
<section id="discretization-using-finite-differences" class="level3">
<h3 class="anchored" data-anchor-id="discretization-using-finite-differences">Discretization Using Finite Differences</h3>
<p>We approximate the second derivatives using the finite difference method. Using a uniform grid with spacing <span class="math inline">\(\Delta x = \Delta y\)</span> we approximate:</p>
<p><span class="math display">\[\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{\Delta x^2}\]</span></p>
<p><span class="math display">\[\frac{\partial^2 u}{\partial y^2} \approx \frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{\Delta y^2}\]</span></p>
<p>Substituting these into the heat equation:</p>
<p><span class="math display">\[\frac{u_{i,j}^{k+1} - u_{i,j}^{k}}{\Delta t} = \frac{u_{i+1,j}^{k} - 2u_{i,j}^{k} + u_{i-1,j}^{k}}{\Delta x^2} + \frac{u_{i,j+1}^{k} - 2u_{i,j}^{k} + u_{i,j-1}^{k}}{\Delta y^2} \]</span></p>
<p>Rearranging for <span class="math inline">\(u_{i,j}^{k+1}\)</span>:</p>
<p><span class="math display">\[u_{i,j}^{k+1} = u_{i,j}^{k} + \epsilon \left( u_{i+1,j}^{k} + u_{i-1,j}^{k} + u_{i,j+1}^{k} + u_{i,j-1}^{k} - 4u_{i,j}^{k} \right)\]</span></p>
<p>where <span class="math inline">\(\epsilon = \frac{ \Delta t}{\Delta x^2}\)</span> is the stability parameter.</p>
</section>
<section id="matrix-representation-of-the-finite-difference-method" class="level3">
<h3 class="anchored" data-anchor-id="matrix-representation-of-the-finite-difference-method">Matrix Representation of the Finite Difference Method</h3>
<p>We represent the system in matrix form:</p>
<p><span class="math display">\[
u_{k+1} = u_k + \epsilon A u_k
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(u_k\)</span> is the flattened temperature grid at time <span class="math inline">\(k\)</span>.</li>
<li><span class="math inline">\(A\)</span> is the finite difference matrix that applies the heat diffusion stencil.</li>
</ul>
<p>The finite difference matrix <span class="math inline">\(A\)</span> for a grid of size <span class="math inline">\(N \times N\)</span> is:</p>
<p><span class="math display">\[
A =
\begin{bmatrix}
T &amp; I &amp; 0 &amp; 0 &amp; \dots &amp; 0  \\
I &amp; T &amp; I &amp; 0 &amp; \dots &amp; 0  \\
0 &amp; I &amp; T &amp; I &amp; \dots &amp; 0  \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \dots &amp; T &amp; I  \\
0 &amp; 0 &amp; 0 &amp; \dots &amp; I &amp; T
\end{bmatrix}
\]</span></p>
<p>where: - <span class="math inline">\(T\)</span> is an <span class="math inline">\(N \times N\)</span> tridiagonal matrix representing left-right interactions:</p>
<p><span class="math display">\[
  T =
  \begin{bmatrix}
  -4 &amp; 1  &amp; 0  &amp; \dots &amp; 0  \\
  1  &amp; -4 &amp; 1  &amp; \dots &amp; 0  \\
  0  &amp; 1  &amp; -4 &amp; \dots &amp; 0  \\
  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots  \\
  0  &amp; 0  &amp; 0  &amp; \dots &amp; -4
  \end{bmatrix}
  \]</span></p>
<ul>
<li><span class="math inline">\(I\)</span> is an <span class="math inline">\(N \times N\)</span> identity matrix that accounts for top/bottom interactions.</li>
</ul>
<p>This matrix enforces:</p>
<ul>
<li>Self-weight (-4) at each grid point.</li>
<li>Neighboring weights (+1) for adjacent grid points.</li>
</ul>
</section>
</section>
<section id="initializing-our-heat-diffusion-simulation" class="level2">
<h2 class="anchored" data-anchor-id="initializing-our-heat-diffusion-simulation">Initializing Our Heat Diffusion Simulation</h2>
<p>For our simulations we will use a grid size <code>N = 101</code> and stability parameter <span class="math inline">\(\epsilon = 0.2\)</span>.</p>
<div id="c4427468-572a-433d-92af-4f18ece5fe3b" class="cell" data-tags="[]" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">101</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>epsilon <span class="op">=</span> <span class="fl">0.2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We initialize the simulation with a single heat source at the center.</p>
<p>We’ll use the following initial condition:</p>
<div id="28c1062a-637d-4025-afaf-19390a8f049a" class="cell" data-tags="[]" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># construct initial condition: 1 unit of heat at midpoint. </span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>u0 <span class="op">=</span> np.zeros((N, N))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>u0[<span class="bu">int</span>(N<span class="op">/</span><span class="dv">2</span>), <span class="bu">int</span>(N<span class="op">/</span><span class="dv">2</span>)] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>plt.imshow(u0)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-3-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="heat-diffusion-with-matrix-vector-multiplication" class="level2">
<h2 class="anchored" data-anchor-id="heat-diffusion-with-matrix-vector-multiplication">Heat Diffusion With Matrix-Vector Multiplication</h2>
<p>In order to begin our 2D heat simulations we’ll create a file <code>heat_equation.py</code> with the following packages:</p>
<div id="505ff101-ec12-4d93-8d02-287fbc7fa466" class="cell" data-tags="[]" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse <span class="im">import</span> diags</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax.experimental.sparse <span class="im">import</span> BCOO</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Using the math above we use matrix-vector multiplication to simulate heat diffusion. The grid is flattened into a 1D vector to apply the finite difference matrix efficiently:</p>
<p><span class="math display">\[
u_{k+1} = u_k + \epsilon A u_k
\]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(A\)</span> is the finite difference matrix of size <span class="math inline">\(N^2 \times N^2\)</span>.</li>
<li><span class="math inline">\(U^k\)</span> is the flattened temperature grid at time <span class="math inline">\(k\)</span>.</li>
<li><span class="math inline">\(\epsilon\)</span> is the stability constant.</li>
</ul>
<p>This formula is represented by the following function:</p>
<div id="48183945-c6fb-40be-a138-8fa536d504b7" class="cell" data-tags="[]" data-execution_count="34">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> advance_time_matvecmul</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> inspect</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(advance_time_matvecmul))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def advance_time_matvecmul(A, u, epsilon):
    """Advances the simulation by one timestep, via matrix-vector multiplication
    Args:
        A: The 2d finite difference matrix, N^2 x N^2. 
        u: N x N grid state at timestep k.
        epsilon: stability constant.

    Returns:
        N x N Grid state at timestep k+1.
    """
    N = u.shape[0]
    u = u + epsilon * (A @ u.flatten()).reshape((N, N))
    return u
</code></pre>
</div>
</div>
<p>In order for the function above to run we also need to write a function <code>get_A()</code> that constructs the matrix A:</p>
<div id="bfe62861-4881-4b27-ac36-a8637364e995" class="cell" data-tags="[]" data-execution_count="35">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> get_A</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(get_A))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def get_A(N):
    """Constructs the finite difference matrix A for the heat equation.
    Args:
        N: Grid size

    Returns:
        A: Finite difference matrix (N^2 x N^2).
    """
    n = N * N
    diagonals = [
        -4 * np.ones(n),  # Main diagonal
        np.ones(n - 1),    # Right neighbor
        np.ones(n - 1),    # Left neighbor
        np.ones(n - N),    # Upper neighbor
        np.ones(n - N)     # Lower neighbor
    ]
    # Apply boundary conditions (preventing wrap-around)
    diagonals[1][(N-1)::N] = 0
    diagonals[2][(N-1)::N] = 0  

    # Construct the finite difference matrix
    A = (
        np.diag(diagonals[0]) +
        np.diag(diagonals[1], 1) +
        np.diag(diagonals[2], -1) +
        np.diag(diagonals[3], N) +
        np.diag(diagonals[4], -N)
    )
    return A
</code></pre>
</div>
</div>
<p>To test our functions and create a heat simulation, we’ll write a function that allows us to specify our type of function that updates the heat distribution from <code>heat_equations.py</code> and the version of matrix A we’ll use in each test.</p>
<p>The following function wraps our testing and visualization for all test cases:</p>
<div id="a4f27ceb-ab44-4cdf-9035-d5db22e96f7a" class="cell" data-tags="[]" data-execution_count="68">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> heat_diffusion_test(func, </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                        u_init, </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                        epsilon, </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                        iterations<span class="op">=</span><span class="dv">2700</span>, </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                        snapshot_interval<span class="op">=</span><span class="dv">300</span>, </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                        matrix_A<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Runs and visualizes the heat diffusion simulation.</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">        - func (function): The function that updates the heat distribution.</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">        - u_init (np.ndarray or jnp.ndarray): Initial heat distribution (N x N grid).</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co">        - epsilon: Stability constant.</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="co">        - iterations: Total number of iterations to run.</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co">        - snapshot_interval: Interval at which to capture snapshots.</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co">        - matrix_A: matrix A.</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co">        - Heat simulation visualizations</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co">        - Total execution time of the simulation.</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Copy the initial condition</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> np.copy(u_init) <span class="cf">if</span> <span class="bu">isinstance</span>(u_init, np.ndarray) <span class="cf">else</span> jnp.array(u_init)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store snapshots for visualization</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    snapshots <span class="op">=</span> []</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Precompile JAX function if applicable</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"jax"</span> <span class="kw">in</span> <span class="bu">str</span>(<span class="bu">type</span>(func)):</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> func(u, epsilon)  <span class="co"># JAX functions require precompilation</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        u.block_until_ready()</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Run the simulation and time it</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, iterations <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> matrix_A <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:  <span class="co"># For matrix-vector multiplication</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> func(A, u, epsilon)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> func(u, epsilon)</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> snapshot_interval <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>            snapshots.append(np.array(u))  <span class="co"># Convert JAX arrays to NumPy if needed</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure JAX computations complete</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(u, jnp.ndarray):</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>        u.block_until_ready()</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    end_time <span class="op">=</span> time.time()</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>    elapsed_time <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot results in a 3x3 grid</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">12</span>))</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, snapshot <span class="kw">in</span> <span class="bu">enumerate</span>(snapshots):</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[idx <span class="op">//</span> <span class="dv">3</span>, idx <span class="op">%</span> <span class="dv">3</span>]</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>        ax.imshow(snapshot, cmap<span class="op">=</span><span class="st">"viridis"</span>, interpolation<span class="op">=</span><span class="st">"nearest"</span>)</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f"Iteration </span><span class="sc">{</span>(idx <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> snapshot_interval<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> elapsed_time</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can now test our first heat simulation using <code>get_A()</code> and <code>heat_diffusion_test()</code> with <code>advance_time_matvecmul()</code> passed as the function in the test arguments:</p>
<div id="040bd774-b75f-462e-bcb9-3c070ca37b2b" class="cell" data-tags="[]" data-execution_count="26">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heat_equation</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> get_A(N)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> heat_diffusion_test(advance_time_matvecmul, u0, epsilon, matrix_A<span class="op">=</span>A)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total execution time: </span><span class="sc">{</span>time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Total execution time: 35.84 seconds</code></pre>
</div>
</div>
<p>This method, while mathematically correct, is computationally expensive (as seen by the runtime of approximately <strong>36 seconds</strong>). In the next sections, we optimize it using sparse matrices and vectorized operations.</p>
</section>
<section id="optimizing-computation-with-sparse-matrices" class="level2">
<h2 class="anchored" data-anchor-id="optimizing-computation-with-sparse-matrices">Optimizing Computation With Sparse Matrices</h2>
<p>The finite difference matrix <span class="math inline">\(A\)</span> is mostly zeros, leading to wasted computations. Using JAX sparse matrices, we store only nonzero values, reducing memory usage and improving efficiency.</p>
<p>We’ll write a function <code>get_sparse_A()</code> that computes the sparse matrix using the batched coordinate <code>BCOO</code> format to only use <span class="math inline">\(O(N^2)\)</span> space for the matrix, and only take <span class="math inline">\(O(N^2)\)</span> time for each update:</p>
<div id="18f33bcd-5888-4cb8-ad6b-95d2470902b3" class="cell" data-tags="[]" data-execution_count="44">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> get_sparse_A</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(get_sparse_A))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def get_sparse_A(N):
    """Constructs the sparse matrix A using JAX sparse format."""
    A = get_A(N) # Get the dense matrix A
    A_sp_matrix = BCOO.fromdense(jnp.array(A)) # Convert dense matrix to JAX sparse format (BCOO)
    return A_sp_matrix
</code></pre>
</div>
</div>
<p>Here, <code>A_sp_matrix</code> is the sparse matrix of A which should make the compute more efficient. We can test this by rerunning the heat simulation using the <code>get_sparse_A()</code> matrix and the same <code>heat_diffusion_test()</code> function, comparing the runtimes:</p>
<div id="b74f7cc9-91cc-4dd8-aaf8-bbfcfa0da5d9" class="cell" data-tags="[]" data-execution_count="48">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heat_equation</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> get_sparse_A(N)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> heat_diffusion_test(advance_time_matvecmul, u0, epsilon, matrix_A<span class="op">=</span>A)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total execution time: </span><span class="sc">{</span>time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Total execution time: 1.86 seconds</code></pre>
</div>
</div>
<p>Runtime for the heat simulation using the sparse matrix of A is <strong>more than 10x faster</strong> (19.27x) at approximately <strong>2 seconds</strong>. Still, we can make the heat simulation more efficient by replacing <code>advance_time_matvecmul()</code>, which utilizes matrix-vector multiplications with vectorized array operations like <code>np.roll()</code>.</p>
</section>
<section id="direct-numpy-vectorization" class="level2">
<h2 class="anchored" data-anchor-id="direct-numpy-vectorization">Direct NumPy Vectorization</h2>
<p>The matrix-vector multiplication approach is useful, particularly in other PDE problems, such as Poisson equations, where the matrix equation must be solved. However, for the heat equation, it is not necessary in terms of computation. Instead, we can use NumPy’s <code>np.roll()</code> to compute updates directly.</p>
<p>We’ll do this by writing the function <code>advance_time_numpy()</code> in <code>heat_equation.py</code>:</p>
<div id="c0c0822c-5a5b-4bc0-bd73-d5e5f4956643" class="cell" data-tags="[]" data-execution_count="50">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> advance_time_numpy</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(advance_time_numpy))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def advance_time_numpy(u, epsilon):
    """Advances the simulation using NumPy's np.roll for boundary handling."""
    u_padded = np.pad(u, pad_width=1, mode='constant', constant_values=0)  # Pad u with zeros
    u_next = u + epsilon * (  # Update u using finite differences
        np.roll(u_padded, 1, axis=0)[1:-1, 1:-1] +  # Shift up
        np.roll(u_padded, -1, axis=0)[1:-1, 1:-1] +  # Shift down
        np.roll(u_padded, 1, axis=1)[1:-1, 1:-1] +  # Shift left
        np.roll(u_padded, -1, axis=1)[1:-1, 1:-1] -  # Shift right
        4 * u  # Subtract central value
    )
    return u_next  # Return updated interior values
</code></pre>
</div>
</div>
<p>The function above works by padding the grid with zeros and computes the transformation using <code>np.roll()</code>. We can understand the function with the visual below:</p>
<div id="57756d5f-23e1-4966-a1b9-39f9060be097" class="cell" data-tags="[]" data-execution_count="57">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Next, we can rerun the simulation using the <code>advance_time_numpy()</code> function as an argument in the <code>visualize_heat_diffusion()</code> function and compare runtimes:</p>
<div id="1ee20010-03d6-40cf-85be-330a742cbc90" class="cell" data-tags="[]" data-execution_count="65">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heat_equation</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> heat_diffusion_test(advance_time_numpy, u0, epsilon)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total execution time: </span><span class="sc">{</span>time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-13-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Total execution time: 0.21 seconds</code></pre>
</div>
</div>
<p>Runtime for the heat simulation using the direct NumPy vectorization is <strong>more than 100x faster</strong> (170.67x) than the base matrix-vector simulation we did at <strong>0.21 seconds</strong>. While already fast, we can achieve a quicker runtime by applying the jit function to essentially the same function <code>advance_time_numpy()</code>, using the JAX package.</p>
</section>
<section id="jax-jit-compilation-for-maximum-speed" class="level2">
<h2 class="anchored" data-anchor-id="jax-jit-compilation-for-maximum-speed">JAX JIT Compilation for Maximum Speed</h2>
<p>Using JAX’s <code>@jax.jit</code>, we can compile the function into optimized machine code, further reducing execution time.</p>
<p>We’ll do this by writing the function <code>advance_time_jax()</code> in <code>heat_equation.py</code> with <code>@jax.jit</code> above the function:</p>
<div id="1bf441b9-56af-4e5e-8aa2-88c797324873" class="cell" data-tags="[]" data-execution_count="66">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> heat_equation <span class="im">import</span> advance_time_jax</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(inspect.getsource(advance_time_jax))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def advance_time_jax(u, epsilon):
    """Advances the simulation using JAX and just-in-time compilation."""
    u_padded = np.pad(u, pad_width=1, mode='constant', constant_values=0)  # Pad u with zeros
    u_next = u + epsilon * (  # Update u using finite differences
        jnp.roll(u_padded, 1, axis=0)[1:-1, 1:-1] +  # Shift up
        jnp.roll(u_padded, -1, axis=0)[1:-1, 1:-1] +  # Shift down
        jnp.roll(u_padded, 1, axis=1)[1:-1, 1:-1] +  # Shift left
        jnp.roll(u_padded, -1, axis=1)[1:-1, 1:-1] -  # Shift right
        4 * u  # Subtract central value
    )
    return u_next  # Return updated interior values
</code></pre>
</div>
</div>
<p>The only difference between the direct NumPy vectorization function is that we use <code>@jax.jit</code> above our function and replace the NumPy calls <code>np</code> with the JAX NumPy calls <code>jnp</code>.</p>
<p>We’ll run the heat diffusion test one last time using the JAX optimized function and compare execution speed:</p>
<div id="c00ed6ba-1795-4cae-a5c8-b39c59f79f6c" class="cell" data-tags="[]" data-execution_count="69">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heat_equation</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span> heat_diffusion_test(advance_time_jax, u0, epsilon)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total execution time: </span><span class="sc">{</span>time<span class="sc">:.2f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-15-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Total execution time: 0.06 seconds</code></pre>
</div>
</div>
<p>Runtime for the heat simulation using the JAX jit operation is <strong>more than 2x faster</strong> (3.5x) than the direct NumPy vectorization simulation we did at <strong>0.06 seconds</strong>. This is nearly <strong>600x faster</strong> than the base matrix-vector simulation.</p>
</section>
<section id="conclusion-applications-to-deep-learning" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-applications-to-deep-learning">Conclusion: Applications to Deep Learning</h2>
<p>Although this blog focuses on simulating heat diffusion, the computational techniques used are directly applicable to deep learning and neural networks. The methods explored, matrix operations, sparse representations, vectorized computations, and JIT compilation, are fundamental to training and optimizing deep learning models.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>