<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Portfolio Performance Analysis – Emil Blaignan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bd9cfa162949bde0a231f530c97869d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Emil Blaignan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./portfolio.html" aria-current="page"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./personal.html"> 
<span class="menu-text">Personal</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/emilblaignan"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/emil-blaignan/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page">
      <h1 class="title">Portfolio Performance Analysis</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta column-page">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block column-page" id="quarto-document-content">





<style>
:root {
  --primary-color: #4361ee;
  --secondary-color: #3a0ca3;
  --accent-color: #f72585;
  --light-bg: #f8f9fa;
  --dark-text: #2b2d42;
  --light-text: #8d99ae;
  --positive-color: #28a745;
  --negative-color: #dc3545;
}

.performance-container {
  border-radius: 16px;
  overflow: hidden;
  box-shadow: 0 4px 8px rgba(0,0,0,0.08);
  background-color: white;
  padding: 20px;
  margin: 30px 0;
}

.chart-container {
  width: 100% !important;
  margin: 20px 0 30px;
  padding: 0;
}

#alpha-chart, #ytd-chart {
  width: 100% !important;
  height: 500px !important; 
}

.loading-message {
  text-align: center;
  padding: 40px;
  color: var(--light-text);
  font-style: italic;
}

.error-message {
  text-align: center;
  padding: 40px;
  color: var(--negative-color);
  font-style: italic;
}

.data-info {
  text-align: right;
  font-size: 0.8rem;
  color: var(--light-text);
  margin-top: 10px;
  position: relative;
  z-index: 10;
}

.performance-metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin-top: 30px;
  position: relative;
  z-index: 20;
}

.metric-card {
  text-align: center;
  padding: 15px 15px 15px 12px;
  border-radius: 10px; 
  box-shadow: 0 6px 8px rgba(0,0,0,0.06); 
  background: white;
  position: relative;
  z-index: 25;
  overflow: visible;
  border-left: 4px solid var(--primary-color);
  transition: transform 0.2s ease, box-shadow 0.2s ease; 
  transform: translateY(0); 
}

.metric-card:hover {
  transform: translateY(-3px); 
  box-shadow: 0 8px 16px rgba(0,0,0,0.12); 
}

.metric-card:nth-child(1) { border-left-color: #003366; }
.metric-card:nth-child(2) { border-left-color: #004D99; }
.metric-card:nth-child(3) { border-left-color: #0066CC; }
.metric-card:nth-child(4) { border-left-color: #4394E5; }
.metric-card:nth-child(5) { border-left-color: #92C5F9; }

.metric-value {
  font-size: 1.8rem;
  font-weight: bold;
  margin: 10px 0;
  text-shadow: 0 1px 1px rgba(0,0,0,0.05);
}

.metric-label {
  font-size: 0.9rem;
  color: var(--light-text);
  margin-bottom: 5px;
}

.metric-description {
  font-size: 0.75rem;
  color: var(--light-text);
  opacity: 0.8;
}

.positive {
  color: var(--positive-color);
}

.negative {
  color: var(--negative-color);
}

.chart-tabs {
  display: flex;
  margin-bottom: 20px;
  border-bottom: 1px solid #e9ecef;
  position: relative;
  z-index: 30;
}

.chart-tab {
  padding: 10px 20px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.2s ease;
  border-bottom: 2px solid transparent;
}

.chart-tab.active {
  border-bottom: 2px solid var(--primary-color);
  color: var(--primary-color);
}

.holdings-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 30px;
}

.holdings-table th {
  background-color: var(--light-bg);
  padding: 10px;
  text-align: left;
  font-weight: 600;
  color: var(--dark-text);
}

.holdings-table td {
  padding: 10px;
  border-bottom: 1px solid #eee;
}

/* New styles for portfolio strategy section */
.strategy-section {
  margin-top: 40px;
}

.strategy-description {
  padding-top: 18px;
  padding-right: 25px;
  padding-bottom: 10px;
  padding-left: 25px;
  border-radius: 12px;
  margin-bottom: 25px;
  line-height: 1.6;
  border-left: 4px solid var(--primary-color);
  position: relative;
  font-size: 1.07rem;
  color: var(--dark-text);
}

.strategy-description::before {
  content: """;
  position: absolute;
  top: 5px;
  left: 15px;
  font-size: 3.5rem;
  color: var(--primary-color);
  opacity: 0.15;
  font-family: Georgia, serif;
  line-height: 1;
}

.strategy-description-content {
  position: relative;
  padding-left: 10px;
}

.portfolio-composition {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 30px;
  margin-top: 20px;
}

.composition-chart {
  height: 500px !important;
  width: 100% !important;
}

.strategy-detail-item {
  margin-bottom: 15px;
  padding: 15px;
  border-left: 4px solid var(--primary-color);
  background-color: var(--light-bg);
  border-radius: 0 8px 8px 0;
}

.strategy-detail-item h4 {
  margin-top: 0;
  margin-bottom: 8px;
  color: var(--dark-text);
}

.strategy-detail-item p {
  margin: 0;
  font-size: 0.9rem;
  color: var(--dark-text);
}

.portfolio-intro {
  font-size: 1.05rem;
  line-height: 1.7;
  color: var(--dark-text);
  max-width: 900px;
  margin: 0 0 25px 0;
  padding: 5px 10px;
  border-radius: 8px;
  position: relative;
}

.portfolio-intro::before {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 3px;
  background: var(--primary-color);
  border-radius: 3px 0 0 3px;
}

.portfolio-intro-note {
  font-style: italic;
  opacity: 0.85;
  margin-top: 8px;
  font-size: 0.95rem;
}

@media (max-width: 768px) {
  .performance-metrics {
    grid-template-columns: 1fr 1fr;
  }
  
  .metric-value {
    font-size: 1.5rem;
  }
  
  .portfolio-composition {
    grid-template-columns: 1fr;
  }
}
</style>
<div class="portfolio-intro">
<p>
This visualization provides a year-to-date analysis of my actively managed investment portfolio’s performance, comparing it to the S&amp;P 500 benchmark (SPY).
</p>
<p class="portfolio-intro-note">
Portfolio metrics are computed based on a non-annualized framework.
</p>
</div>
<p><em>Note: The data is updated daily via an automated GitHub Action.</em></p>
<div class="performance-container">
<div class="chart-tabs">
<div id="tab-ytd" class="chart-tab active">
YTD Performance
</div>
<div id="tab-risk" class="chart-tab">
Risk Analysis
</div>
<div id="tab-alpha" class="chart-tab">
Alpha Evolution
</div>
</div>
<div id="ytd-chart" class="chart-container" style="height: 500px;">
<div class="loading-message">

</div>
</div>
<div id="risk-chart" class="chart-container" style="height: 400px; display: none;">
<div class="loading-message">
Loading risk analysis…
</div>
</div>
<div id="alpha-chart" class="chart-container" style="height: 500px; display: none;">
<div class="loading-message">

</div>
</div>
<div id="alpha-note" class="metrics-note" style="font-size: 0.8rem; color: var(--light-text); font-style: italic; opacity: 0.9; margin: 5px 0 20px; text-align: center; display: none;">
<p>Note: Rolling metrics shown in this chart use 20-day windows and will differ from the YTD cumulative metrics displayed in the summary cards below.</p>
</div>
<div id="performance-metrics" class="performance-metrics">
<!-- Metrics will be inserted here -->
</div>
<div id="data-info" class="data-info">

</div>
<div id="holdings-table-container">
<!-- Holdings table will be inserted here -->
</div>
<!-- Portfolio Strategy Section -->
<div class="strategy-section">
<h3 class="anchored">
Portfolio Strategy
</h3>
<div class="strategy-description">
<div class="strategy-description-content">
<p>This portfolio follows a risk-aware modern approach based on Markowitz mean-variance optimization, seeking to balance risk and return across diverse market conditions. The allocation targets defensive positioning with inflation protection while maintaining exposure to secular growth trends. Periodic rebalancing and factor analysis ensure the portfolio maintains its intended risk characteristics while adapting to changing market dynamics.</p>
</div>
</div>
<div class="portfolio-composition">
<div>
<div id="composition-chart" class="composition-chart">

</div>
</div>
<div>
<div class="strategy-detail-item">
<h4 class="anchored">
Defensive Core &amp; Inflation Hedge (49.7%)
</h4>
<p>
Combines insurance sector exposure (PGR) and gold (IAU) to create a stabilizing core with inflation protection. These assets typically provide downside protection during market stress while offering meaningful appreciation potential.
</p>
</div>
<div class="strategy-detail-item">
<h4 class="anchored">
Technology &amp; Growth (23.3%)
</h4>
<p>
Balanced exposure to established technology leaders (MSFT, NOW) and high-growth semiconductor (NVDA) providing both stability and innovation upside. Position sizing reflects both opportunity and volatility considerations.
</p>
</div>
<div class="strategy-detail-item">
<h4 class="anchored">
Consumer &amp; Retail Strength (15.2%)
</h4>
<p>
Focus on market leaders (WMT, COST) with pricing power that have demonstrated resilience across economic cycles and can pass through inflation to protect margins.
</p>
</div>
<div class="strategy-detail-item">
<h4 class="anchored">
Financial &amp; Cyclical Exposure (11.8%)
</h4>
<p>
Targeted allocation to high-quality financials (JPM) positioned to benefit from interest rate environment and industrial leader (CAT) leveraged to infrastructure and construction activity.
</p>
</div>
</div>
</div>
</div>
</div>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.7/dayjs.min.js"></script>
<script>
// Configuration parameters
const CONFIG = {
  rollingWindow: 20,  // Number of days for rolling window calculations
  tradingDays: 252    // Trading days in a year 
};

// Define sector classifications and colors for the composition chart
const SECTORS = {
  "Defensive Core & Inflation Hedge": {
    color: "#003366",
    holdings: {
      "PGR": { weight: 0.2703},
      "IAU": { weight: 0.2394}
    }
  },
  "Technology & Growth": {
    color: "#004D99",
    holdings: {
      "NVDA": { weight: 0.1229},
      "MSFT": { weight: 0.0554},
      "NOW": { weight: 0.0551},
      "RDDT": { weight: 0.0385}
    }
  },
  "Consumer & Retail": {
    color: "#0066CC",
    holdings: {
      "WMT": { weight: 0.1109},
      "COST": { weight: 0.0414}
    }
  },
  "Financial & Cyclical": {
    color: "#92C5F9",
    holdings: {
      "JPM": { weight: 0.0368},
      "CAT": { weight: 0.0293}
    }
  }
};

// Main analysis function
async function analyzePortfolio() {
  try {
    // 1. Load data
    const response = await fetch('data/portfolio-performance.json?v=' + new Date().getTime());
    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
    const data = await response.json();
    
    console.log("Data loaded successfully:", data);
    
    // 2. Calculate daily returns from YTD percentages
    const portfolioReturns = calculateDailyReturnsFromYTD(data.timeSeriesData.portfolio);
    const benchmarkReturns = calculateDailyReturnsFromYTD(data.timeSeriesData.benchmark);
    
    // 3. Extract SOFR rates and convert to decimal
    const sofrRates = data.timeSeriesData.sofr_rates_pct.map(rate => rate / 100);
    
    // 4. Calculate metrics
    const metrics = calculateFinancialMetrics(
      portfolioReturns, 
      benchmarkReturns,
      sofrRates
    );
    
    // 5. Calculate rolling metrics
    const rollingMetrics = calculateRollingMetrics(
      data.timeSeriesData.dates.slice(1), // Skip first date (no return)
      portfolioReturns,
      benchmarkReturns,
      sofrRates.slice(1) // Skip first SOFR rate to align with returns
    );
    
    // 6. Update UI
    renderCharts(data, metrics, rollingMetrics);
    updateMetricsDisplay(metrics, data);
    updatePortfolioTable(data);
    updateDataInfo(data);
    
    // 7. Create portfolio composition chart
    renderCompositionChart();
    
  } catch (error) {
    console.error("Analysis failed:", error);
    document.getElementById('ytd-chart').innerHTML = `
      <div class="error-message">Failed to load data: ${error.message}</div>
    `;
  }
}

// Function to render the portfolio composition chart
function renderCompositionChart() {
  // Prepare data for sunburst chart
  const labels = ['Portfolio'];
  const parents = [''];
  const values = [1]; // Total portfolio is 1 (100%)
  const hovertext = [''];
  const colors = ['white']; // Center is white

  // Add sectors and holdings
  Object.entries(SECTORS).forEach(([sectorName, sectorData]) => {
    const sectorWeight = Object.values(sectorData.holdings).reduce((sum, h) => sum + h.weight, 0);
    
    // Add sector
    labels.push(sectorName);
    parents.push('Portfolio');
    values.push(sectorWeight);
    hovertext.push(`${(sectorWeight * 100).toFixed(1)}%`);
    colors.push(sectorData.color);
    
    // Add holdings for this sector
    Object.entries(sectorData.holdings).forEach(([ticker, holding]) => {
      labels.push(ticker);
      parents.push(sectorName);
      values.push(holding.weight);
      hovertext.push(`${(holding.weight * 100).toFixed(2)}%`);
      
      // Use a lighter shade of the sector color
      const lighterColor = lightenColor(sectorData.color, 30);
      colors.push(lighterColor);
    });
  });

  // Create sunburst chart
  Plotly.newPlot('composition-chart', [{
    type: 'sunburst',
    labels: labels,
    parents: parents,
    values: values,
    text: hovertext,
    hoverinfo: 'text+label',
    branchvalues: 'total',
    marker: {
      colors: colors,
      line: { width: 1, color: '#fff' }
    },
    textfont: { size: 12 }
  }], {
    title: 'Portfolio Composition',
    margin: { t: 30, l: 0, r: 0, b: 0 },
    paper_bgcolor: 'rgba(0,0,0,0)'
  });
}

// Helper function to lighten a color
function lightenColor(hex, percent) {
  // Remove the # if present
  hex = hex.replace(/^#/, '');
  
  // Convert to RGB
  let r = parseInt(hex.substring(0, 2), 16);
  let g = parseInt(hex.substring(2, 4), 16);
  let b = parseInt(hex.substring(4, 6), 16);
  
  // Lighten
  r = Math.min(255, Math.floor(r + (255 - r) * (percent / 100)));
  g = Math.min(255, Math.floor(g + (255 - g) * (percent / 100)));
  b = Math.min(255, Math.floor(b + (255 - b) * (percent / 100)));
  
  // Convert back to hex
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Calculate daily returns from YTD percentages
function calculateDailyReturnsFromYTD(ytdPercentages) {
  const returns = [];
  
  // Convert percentages to decimal returns (e.g., 10.5% -> 0.105)
  const ytdDecimals = ytdPercentages.map(p => p / 100);
  
  // Calculate daily returns
  for (let i = 1; i < ytdDecimals.length; i++) {
    // If previous YTD return was exactly 0, we need special handling to avoid division by zero
    if (ytdDecimals[i-1] === 0) {
      returns.push(ytdDecimals[i]); // This day's return is just the YTD return
    } else {
      // Formula: daily_return = (1 + ytd_today) / (1 + ytd_yesterday) - 1
      const dailyReturn = (1 + ytdDecimals[i]) / (1 + ytdDecimals[i-1]) - 1;
      returns.push(dailyReturn);
    }
  }
  
  return returns;
}

// Calculate rolling window metrics
function calculateRollingMetrics(dates, portfolioReturns, benchmarkReturns, riskFreeRates) {
  // Initialize arrays to store rolling metrics
  const rollingAlpha = [];
  const rollingBeta = [];
  const rollingInformationRatio = [];
  
  // Need at least a full window of data
  if (portfolioReturns.length < CONFIG.rollingWindow) {
    return { rollingAlpha, rollingBeta, rollingInformationRatio, rollingDates: [] };
  }
  
  // For each window of data
  for (let i = CONFIG.rollingWindow; i <= portfolioReturns.length; i++) {
    // Extract data for the current window
    const windowPortfolioReturns = portfolioReturns.slice(i - CONFIG.rollingWindow, i);
    const windowBenchmarkReturns = benchmarkReturns.slice(i - CONFIG.rollingWindow, i);
    
    // Use the latest risk-free rate for this window
    const riskFreeRate = riskFreeRates[i - 1] || riskFreeRates[riskFreeRates.length - 1];
    
    // Calculate beta
    const covar = covariance(windowPortfolioReturns, windowBenchmarkReturns);
    const benchmarkVariance = variance(windowBenchmarkReturns);
    const beta = benchmarkVariance !== 0 ? covar / benchmarkVariance : 1.0;
    
    // Calculate average returns for window
    const avgPortfolioReturn = mean(windowPortfolioReturns);
    const avgBenchmarkReturn = mean(windowBenchmarkReturns);
    
    // Calculate alpha for the window (WITHOUT annualizing - just for this window)
    const alpha = avgPortfolioReturn - (riskFreeRate / CONFIG.tradingDays + beta * (avgBenchmarkReturn - riskFreeRate / CONFIG.tradingDays));
    
    // Calculate excess returns for information ratio
    const excessReturns = windowPortfolioReturns.map((r, idx) => r - windowBenchmarkReturns[idx]);
    const trackingError = stdDev(excessReturns);
    
    // Calculate information ratio for the window
    const informationRatio = trackingError !== 0 ? 
      (avgPortfolioReturn - avgBenchmarkReturn) / trackingError : 0;
    
    // Store results
    rollingAlpha.push(alpha * 100); // Convert to percentage
    rollingBeta.push(beta);
    rollingInformationRatio.push(informationRatio);
  }
  
  // Extract dates for the rolling metrics
  // Each date represents the end of a rolling window
  const rollingDates = dates.slice(CONFIG.rollingWindow - 1);
  
  return {
    rollingAlpha,
    rollingBeta,
    rollingInformationRatio,
    rollingDates
  };
}

// Core financial calculations - using actual YTD metrics rather than annualized
function calculateFinancialMetrics(portfolioReturns, benchmarkReturns, riskFreeRates) {
  // Safety check
  if (portfolioReturns.length === 0 || benchmarkReturns.length === 0) {
    return {
      alpha: 0,
      beta: 1.0,
      sharpeRatio: 0,
      informationRatio: 0,
      ytdReturn: 0,
      correlation: 0
    };
  }

  // Calculate cumulative returns - what we actually achieved YTD
  const cumulativePortfolioReturn = portfolioReturns.reduce((cum, ret) => (1 + cum) * (1 + ret) - 1, 0);
  const cumulativeBenchmarkReturn = benchmarkReturns.reduce((cum, ret) => (1 + cum) * (1 + ret) - 1, 0);
  
  // Average daily risk-free rate
  const avgRiskFreeRate = mean(riskFreeRates) / CONFIG.tradingDays; // Daily rate
  
  // Calculate daily statistics
  const avgPortfolioReturn = mean(portfolioReturns);
  const avgBenchmarkReturn = mean(benchmarkReturns);
  const portStdDev = stdDev(portfolioReturns);
  const benchStdDev = stdDev(benchmarkReturns);
  
  // Calculate beta
  const portfolioVariance = variance(portfolioReturns);
  const benchmarkVariance = variance(benchmarkReturns);
  const covar = covariance(portfolioReturns, benchmarkReturns);
  
  // Safety check for division by zero
  const beta = benchmarkVariance !== 0 ? covar / benchmarkVariance : 1.0;
  
  // Calculate YTD alpha (CAPM) - NOT annualized
  // Using cumulative returns for YTD period
  const ytdRiskFreeReturn = riskFreeRates.reduce((cum, rate) => 
    (1 + cum) * (1 + rate / CONFIG.tradingDays) - 1, 0);
  
  const alpha = cumulativePortfolioReturn - (ytdRiskFreeReturn + beta * (cumulativeBenchmarkReturn - ytdRiskFreeReturn));
  
  // Calculate Sharpe ratio for YTD
  const excessReturn = cumulativePortfolioReturn - ytdRiskFreeReturn;
  const sharpeRatio = portStdDev !== 0 ? excessReturn / (portStdDev * Math.sqrt(portfolioReturns.length)) : 0;
  
  // Calculate excess returns for information ratio
  const excessReturns = portfolioReturns.map((r, i) => r - benchmarkReturns[i]);
  const trackingError = stdDev(excessReturns);
  
  // Calculate information ratio
  const informationRatio = trackingError !== 0 ? 
    (cumulativePortfolioReturn - cumulativeBenchmarkReturn) / (trackingError * Math.sqrt(portfolioReturns.length)) : 0;
  
  // Calculate correlation
  const correlation = (portStdDev !== 0 && benchStdDev !== 0) ? 
    covar / (portStdDev * benchStdDev) : 0;
  
  return {
    alpha: alpha,              // YTD alpha
    beta: beta,                // Beta
    sharpeRatio: sharpeRatio,  // YTD Sharpe
    informationRatio: informationRatio, // YTD Information Ratio
    ytdReturn: cumulativePortfolioReturn,
    correlation: correlation
  };
}

// Statistical helper functions
function mean(arr) { return arr.reduce((a,b) => a + b, 0) / arr.length; }
function variance(arr) {
  const m = mean(arr);
  return arr.reduce((a,b) => a + Math.pow(b - m, 2), 0) / arr.length;
}
function stdDev(arr) { return Math.sqrt(variance(arr)); }
function covariance(arr1, arr2) {
  const m1 = mean(arr1), m2 = mean(arr2);
  let sum = 0;
  for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {
    sum += (arr1[i] - m1) * (arr2[i] - m2);
  }
  return sum / Math.min(arr1.length, arr2.length);
}

// UI Rendering functions
function renderCharts(data, metrics, rollingMetrics) {
  // YTD Performance Chart
  Plotly.newPlot('ytd-chart', [{
    x: data.timeSeriesData.dates,
    y: data.timeSeriesData.portfolio,
    type: 'scatter',
    mode: 'lines',
    name: 'Portfolio',
    line: {
      color: '#4361ee',
      width: 3
    }
  }, {
    x: data.timeSeriesData.dates,
    y: data.timeSeriesData.benchmark,
    type: 'scatter',
    mode: 'lines',
    name: 'S&P 500',
    line: {
      color: '#e63946',
      width: 2,
      dash: 'dot'
    }
  }], {
    title: 'YTD Performance Comparison',
    xaxis: {
      title: 'Date',
      showgrid: false
    },
    yaxis: {
      title: 'Performance (%)',
      tickformat: '.1f',
      showgrid: true,
      gridcolor: '#f0f0f0',
      zeroline: true,
      zerolinecolor: '#aaaaaa'
    },
    legend: {
      orientation: 'h',
      y: 1.06
    },
    hovermode: 'closest',
    margin: {t: 50, l: 50, r: 10, b: 50},
    plot_bgcolor: 'white'
  });
  
  // Risk Analysis Chart
  Plotly.newPlot('risk-chart', [{
    type: 'bar',
    x: ['Alpha', 'Beta', 'Sharpe', 'Info Ratio'],
    y: [metrics.alpha * 100, metrics.beta, metrics.sharpeRatio, metrics.informationRatio],
    marker: {
      color: ['#4361ee', '#3a0ca3', '#f72585', '#00b4d8']
    },
    text: [
      (metrics.alpha * 100).toFixed(2) + '%', 
      metrics.beta.toFixed(2), 
      metrics.sharpeRatio.toFixed(2),
      metrics.informationRatio.toFixed(2)
    ],
    textposition: 'auto'
  }], {
    title: 'YTD Risk Metrics',
    yaxis: {
      title: 'Value',
      showgrid: true,
      gridcolor: '#f0f0f0',
      autorange: true,
      tickformat: '.2f'
    },
    margin: {t: 50, l: 50, r: 20, b: 50},
    plot_bgcolor: 'white'
  });
  
  // Alpha Evolution Chart
  Plotly.newPlot('alpha-chart', [{
    x: rollingMetrics.rollingDates,
    y: rollingMetrics.rollingAlpha,
    type: 'scatter',
    mode: 'lines',
    name: 'Alpha (%)',
    line: {
      color: '#4361ee',
      width: 3
    },
    yaxis: 'y'
  }, {
    x: rollingMetrics.rollingDates,
    y: rollingMetrics.rollingInformationRatio,
    type: 'scatter',
    mode: 'lines',
    name: 'Information Ratio',
    line: {
      color: '#f72585',
      width: 2
    },
    yaxis: 'y2'
  }], {
    title: 'Rolling ' + CONFIG.rollingWindow + '-Day Risk Metrics',
    xaxis: {
      title: 'Date',
      showgrid: false,
      autorange: true,
      fixedrange: false // Allow zoom/pan
    },
    yaxis: {
      title: 'Alpha (%)',
      tickformat: '.2f',
      showgrid: true,
      gridcolor: '#f0f0f0',
      zeroline: true,
      zerolinecolor: '#aaaaaa',
      fixedrange: false
    },
    yaxis2: {
      title: 'Information Ratio',
      titlefont: {color: '#f72585'},
      tickfont: {color: '#f72585'},
      overlaying: 'y',
      side: 'right',
      showgrid: false,
      fixedrange: false
    },
    legend: {
      orientation: 'h',
      y: 1.06 // Adjust positioning if needed
    },
    hovermode: 'closest',
    margin: { t: 50, l: 50, r: 40, b: 50 }, // Changed r from 50 to 20
    plot_bgcolor: 'white',
    autosize: true // Ensure autosize is true
  });
}

function updateMetricsDisplay(metrics, data) {
  const portfolioYTD = data.dailySnapshot?.portfolio?.performance || 
                        data.timeSeriesData.portfolio[data.timeSeriesData.portfolio.length - 1];
  const benchmarkYTD = data.dailySnapshot?.benchmark?.performance || 
                        data.timeSeriesData.benchmark[data.timeSeriesData.benchmark.length - 1];
  
  // Format alpha as percentage with 2 decimal places
  const formattedAlpha = (metrics.alpha * 100).toFixed(2) + '%';
  
  document.getElementById('performance-metrics').innerHTML = `
    <div class="metric-card">
      <div class="metric-label">Portfolio YTD</div>
      <div class="metric-value ${portfolioYTD >= 0 ? 'positive' : 'negative'}">
        ${portfolioYTD.toFixed(2)}%
      </div>
      <div class="metric-description">Current performance</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-label">S&P 500 YTD</div>
      <div class="metric-value ${benchmarkYTD >= 0 ? 'positive' : 'negative'}">
        ${benchmarkYTD.toFixed(2)}%
      </div>
      <div class="metric-description">Benchmark performance</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-label">Alpha</div>
      <div class="metric-value ${metrics.alpha >= 0 ? 'positive' : 'negative'}">
        ${formattedAlpha}
      </div>
      <div class="metric-description">YTD excess return</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-label">Beta</div>
      <div class="metric-value">${metrics.beta.toFixed(2)}</div>
      <div class="metric-description">Market sensitivity</div>
    </div>
    
    <div class="metric-card">
      <div class="metric-label">Information Ratio</div>
      <div class="metric-value ${metrics.informationRatio >= 0 ? 'positive' : 'negative'}">
        ${metrics.informationRatio.toFixed(2)}
      </div>
      <div class="metric-description">Risk-adjusted relative return</div>
    </div>
  `;
}

function updatePortfolioTable(data) {
  // Check if we have holdings data
  if (!data.dailySnapshot?.portfolio?.stocks) {
    // No table to show
    document.getElementById('holdings-table-container').innerHTML = '';
    return;
  }
  
  const stocks = data.dailySnapshot.portfolio.stocks;
  
  let tableHTML = `
    <h3>Portfolio Holdings</h3>
    <table class="holdings-table">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Weight</th>
          <th>Price</th>
          <th>YTD Performance</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  stocks.forEach(stock => {
    tableHTML += `
      <tr>
        <td><strong>${stock.ticker}</strong></td>
        <td>${(stock.weight * 100).toFixed(2)}%</td>
        <td>$${stock.price.toFixed(2)}</td>
        <td class="${stock.ytdChange >= 0 ? 'positive' : 'negative'}">
          ${stock.ytdChange.toFixed(2)}%
        </td>
      </tr>
    `;
  });
  
  tableHTML += `
      </tbody>
    </table>
  `;
  
  document.getElementById('holdings-table-container').innerHTML = tableHTML;
}

function updateDataInfo(data) {
  // Show last updated date and SOFR rate information
  const sofrRate = data.dailySnapshot?.riskFree?.rate || 
    data.timeSeriesData.sofr_rates_pct[data.timeSeriesData.sofr_rates_pct.length - 1];
  
  document.getElementById('data-info').innerHTML = 
    `Last updated: ${data.lastUpdated || data.timestamp} | Current SOFR Rate: ${sofrRate}%`;
}

function setupTabSwitching() {
  const tabs = {
    'tab-ytd': 'ytd-chart',
    'tab-risk': 'risk-chart',
    'tab-alpha': 'alpha-chart'
  };
  // Get references to the chart container elements ONCE
  const chartContainers = {
    'tab-ytd': document.getElementById('ytd-chart'),
    'tab-risk': document.getElementById('risk-chart'),
    'tab-alpha': document.getElementById('alpha-chart')
  };
  const alphaNote = document.getElementById('alpha-note'); // Get alpha note element

  Object.keys(tabs).forEach(tabId => {
    document.getElementById(tabId).addEventListener('click', function() {
      let newlyVisibleChartElement = null;

      // Deactivate all tabs and hide charts
      Object.keys(tabs).forEach(id => {
        document.getElementById(id).classList.remove('active');
        if (chartContainers[id]) { // Check if element exists
            chartContainers[id].style.display = 'none';
        }
      });

      // Activate selected tab and show chart
      document.getElementById(tabId).classList.add('active');
      newlyVisibleChartElement = chartContainers[tabId]; // Get the element for the clicked tab
      if (newlyVisibleChartElement) {
        newlyVisibleChartElement.style.display = 'block';
      }

      // --- ADDED: Explicitly resize the *visible* chart ---
      if (newlyVisibleChartElement) {
         try {
            // Use Plotly.Plots.resize which works on the container div
            Plotly.Plots.resize(newlyVisibleChartElement);
            console.log(`Resized chart: ${newlyVisibleChartElement.id}`);
         } catch (e) {
             // It might throw an error if the plot isn't fully initialized yet,
             // especially on the very first load, but should work on subsequent clicks.
             console.warn(`Could not resize chart ${newlyVisibleChartElement.id} immediately:`, e);
         }
      }
      // --- END ADDED ---

      // Show/hide the alpha chart note based on the active tab
      if (tabId === 'tab-alpha') {
          alphaNote.style.display = 'block';
      } else {
          alphaNote.style.display = 'none';
      }

    });
  });

  // Initial setup: Hide alpha note if alpha tab isn't the default active one on load
  if (!document.getElementById('tab-alpha').classList.contains('active')) {
       alphaNote.style.display = 'none';
   } else {
       alphaNote.style.display = 'block'; // Ensure it's shown if alpha IS the default
   }
}

// Initialize when DOM loads
document.addEventListener('DOMContentLoaded', () => {
  console.log("DOM loaded, starting portfolio analysis...");
  analyzePortfolio();
  setupTabSwitching();
});
</script>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Metrics Explained
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>Alpha</strong>: YTD excess returns after accounting for market risk (positive = outperformance)</li>
<li><strong>Beta</strong>: Measures portfolio volatility relative to market (1 = market risk)</li>
<li><strong>Sharpe Ratio</strong>: Risk-adjusted absolute returns (higher = better)</li>
<li><strong>Information Ratio</strong>: Risk-adjusted relative returns vs benchmark (higher = better)</li>
<li><strong>Rolling Metrics</strong>: Computed using a 20-day rolling window to show evolution over time</li>
</ul>
</div>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>